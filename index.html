<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¥“ä¹‹è°·BOSSé‡ç”Ÿæ™‚é–“ç³»çµ±</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #0a0a1a 0%, #15152b 100%);
            color: #ffffff;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(21, 21, 43, 0.5);
            border-radius: 15px;
            border: 1px solid #00ccff;
        }

        .header h1 {
            color: #00ccff;
            font-size: 2em;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        .header p {
            color: #00ff99;
            font-size: 1.1em;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #00ccff;
        }

        .tab {
            padding: 12px 24px;
            background: #1e1e3a;
            border: 1px solid #00ccff;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            color: #a0a0c0;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #2a2a4a;
        }

        .tab.active {
            background: #00ccff;
            color: #0a0a1a;
            font-weight: bold;
        }

        .tab-content {
            display: none;
            background: #15152b;
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #00ccff;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            background: #1e1e3a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #00ccff;
        }

        .section h2 {
            color: #00ccff;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            color: #a0a0c0;
            font-size: 0.9em;
        }

        select, input[type="text"], input[type="number"] {
            padding: 10px;
            background: #0a0a1a;
            border: 1px solid #00ccff;
            border-radius: 5px;
            color: #ffffff;
            font-size: 1em;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #00ff99;
            box-shadow: 0 0 5px rgba(0, 255, 153, 0.5);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .info-box {
            background: rgba(0, 204, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #00ccff;
        }

        .info-box p {
            color: #00ff99;
            margin: 5px 0;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 12px 24px;
            background: #1e1e3a;
            border: 1px solid #00ccff;
            border-radius: 5px;
            color: #ffffff;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }

        button:hover {
            background: #00ccff;
            color: #0a0a1a;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 204, 255, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button.danger {
            border-color: #ff3366;
        }

        button.danger:hover {
            background: #ff3366;
            color: #ffffff;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2a2a4a;
        }

        th {
            background: #0a0a1a;
            color: #00ccff;
            font-weight: bold;
            position: sticky;
            top: 0;
        }

        tr:hover {
            background: rgba(0, 204, 255, 0.1);
        }

        tr.selected {
            background: rgba(0, 204, 255, 0.2);
        }

        .status-waiting {
            color: #a0a0c0;
        }

        .status-possible {
            color: #ff9800;
            font-weight: bold;
        }

        .status-definite {
            color: #ff3366;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .status-display {
            background: #0a0a1a;
            padding: 20px;
            border-radius: 10px;
            max-height: 600px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
        }

        .boss-status-card {
            background: #1e1e3a;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #00ccff;
        }

        .boss-status-card h3 {
            color: #00ccff;
            margin-bottom: 10px;
        }

        .boss-status-card p {
            margin: 5px 0;
            color: #a0a0c0;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #1e1e3a;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00ccff;
            max-width: 400px;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        @keyframes slideIn {
            from {
                transform: translateX(500px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .notification.success {
            border-color: #00ff99;
        }

        .notification.error {
            border-color: #ff3366;
        }

        .notification.warning {
            border-color: #ff9800;
        }

        .scrollbar::-webkit-scrollbar {
            width: 10px;
        }

        .scrollbar::-webkit-scrollbar-track {
            background: #0a0a1a;
        }

        .scrollbar::-webkit-scrollbar-thumb {
            background: #00ccff;
            border-radius: 5px;
        }

        .scrollbar::-webkit-scrollbar-thumb:hover {
            background: #00ff99;
        }

        .current-time {
            text-align: center;
            font-size: 1.2em;
            color: #00ff99;
            margin-bottom: 20px;
            padding: 10px;
            background: rgba(0, 255, 153, 0.1);
            border-radius: 5px;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .hint {
            color: #00ff99;
            font-size: 0.9em;
            margin-top: 10px;
            font-style: italic;
        }

        @media (max-width: 768px) {
            .input-group {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 1.5em;
            }

            table {
                font-size: 0.85em;
            }

            th, td {
                padding: 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ® æ¥“ä¹‹è°·BOSSé‡ç”Ÿæ™‚é–“ç³»çµ±</h1>
            <p>å¯¦æ™‚ç›£æ§èˆ‡æé†’</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab(0)">BOSSè¨˜éŒ„</div>
            <div class="tab" onclick="switchTab(1)">é‡ç”Ÿç‹€æ…‹</div>
            <div class="tab" onclick="switchTab(2)">BOSSåˆ—è¡¨</div>
            <div class="tab" onclick="switchTab(3)">æ”¹å–„å»ºè­°</div>
        </div>

        <div class="tab-content active" id="tab-record">
            <div class="section">
                <h2>è¨˜éŒ„æ–°BOSSæ“Šæ®º</h2>
                <div class="input-group">
                    <div class="input-field">
                        <label>é¸æ“‡BOSS:</label>
                        <select id="boss-select" onchange="onBossSelected()">
                            <option value="">è«‹é¸æ“‡...</option>
                        </select>
                    </div>
                    <div class="input-field">
                        <label>é »é“:</label>
                        <input type="number" id="channel-input" value="1" min="1" max="20">
                    </div>
                </div>



                <div class="info-box" id="boss-info" style="display: none;">
                    <p id="map-info"></p>
                    <p id="time-info"></p>
                </div>

                <div class="button-group">
                    <button onclick="recordBoss()">ğŸ“ è¨˜éŒ„æ“Šæ®ºæ™‚é–“ (Enter)</button>
                </div>
                <p class="hint">ğŸ’¡ æç¤º: é¸æ“‡BOSS â†’ è¼¸å…¥é »é“ â†’ æŒ‰Enteræˆ–é»æ“ŠæŒ‰éˆ•è¨˜éŒ„</p>
            </div>

            <div class="section">
                <h2>ç•¶å‰è¨˜éŒ„ä¸­çš„BOSS</h2>
                <div style="overflow-x: auto;">
                    <table id="record-table">
                        <thead>
                            <tr>
                                <th><input type="checkbox" id="select-all" onchange="toggleSelectAll()"></th>
                                <th>BOSSåç¨±</th>
                                <th>é »é“</th>
                                <th>æ“Šæ®ºæ™‚é–“</th>
                                <th>æœ€æ—©é‡ç”Ÿ</th>
                                <th>æœ€æ™šé‡ç”Ÿ</th>
                                <th>ç‹€æ…‹</th>
                                <th>æœ€å¾Œå·¡é‚</th>
                                <th>æ“ä½œ</th>
                            </tr>
                        </thead>
                        <tbody id="record-tbody">
                        </tbody>
                    </table>
                </div>
                <div class="action-buttons">
                    <button onclick="deleteRecords()">ğŸ—‘ï¸ åˆªé™¤é¸å–è¨˜éŒ„</button>
                    <button onclick="respawnBoss()">ğŸ”„ å®Œæˆæ“Šæ®ºé‡æ–°è¨ˆæ™‚</button>
                    <button onclick="patrolBoss()">ğŸ‘€ å·¡é‚æ‰“å¡</button>
                    <button onclick="clearAll()" class="danger">âš ï¸ æ¸…ç©ºæ‰€æœ‰è¨˜éŒ„</button>
                </div>
            </div>
        </div>

        <div class="tab-content" id="tab-status">
            <div class="current-time" id="current-time"></div>
            <div class="status-display scrollbar" id="status-display">
                <p style="text-align: center; color: #a0a0c0;">ç›®å‰æ²’æœ‰è¨˜éŒ„ä¸­çš„BOSS</p>
            </div>
        </div>

        <div class="tab-content" id="tab-settings">
            <div class="section">
                <h2>BOSSè³‡è¨Šä¸€è¦½</h2>
                <div style="overflow-x: auto;">
                    <table id="boss-list-table">
                        <thead>
                            <tr>
                                <th>BOSSåç¨±</th>
                                <th>é‡ç”Ÿæ™‚é–“ç¯„åœ</th>
                                <th>åœ°åœ–</th>
                            </tr>
                        </thead>
                        <tbody id="boss-list-tbody">
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <div class="tab-content" id="tab-feedback">
            <div class="section">
                <h2>ğŸ’¡ æ”¹å–„å»ºè­°</h2>
                <p style="color: #a0a0c0; margin-bottom: 20px;">
                    å¦‚æœæ‚¨åœ¨ä½¿ç”¨éç¨‹ä¸­æœ‰ä»»ä½•æ”¹å–„å»ºè­°æˆ–ç™¼ç¾å•é¡Œï¼Œæ­¡è¿é€éä¸‹æ–¹è¡¨å–®å‘Šè¨´æˆ‘å€‘ï¼
                </p>
                
                <div class="input-group">
                    <div class="input-field" style="grid-column: 1 / -1;">
                        <label>å»ºè­°é¡å‹:</label>
                        <select id="feedback-type" style="width: 100%;">
                            <option value="åŠŸèƒ½å»ºè­°">åŠŸèƒ½å»ºè­°</option>
                            <option value="éŒ¯èª¤å›å ±">éŒ¯èª¤å›å ±</option>
                            <option value="UI/UXæ”¹å–„">UI/UXæ”¹å–„</option>
                            <option value="å…¶ä»–">å…¶ä»–</option>
                        </select>
                    </div>
                </div>

                <div class="input-group">
                    <div class="input-field" style="grid-column: 1 / -1;">
                        <label>è©³ç´°èªªæ˜:</label>
                        <textarea id="feedback-content" 
                                  style="width: 100%; min-height: 150px; padding: 10px; 
                                         background: #0a0a1a; border: 1px solid #00ccff; 
                                         border-radius: 5px; color: #ffffff; font-family: inherit; 
                                         font-size: 1em; resize: vertical;"
                                  placeholder="è«‹è©³ç´°æè¿°æ‚¨çš„å»ºè­°æˆ–å•é¡Œ..."></textarea>
                    </div>
                </div>

                <div class="input-group">
                    <div class="input-field">
                        <label>è¯çµ¡æ–¹å¼ (é¸å¡«):</label>
                        <input type="text" id="feedback-contact" 
                               placeholder="Discord ID æˆ–å…¶ä»–è¯çµ¡æ–¹å¼"
                               style="width: 100%;">
                    </div>
                </div>

                <div class="button-group">
                    <button onclick="submitFeedback()" style="padding: 15px 30px; font-size: 1.1em;">
                        ğŸ“¨ æäº¤å»ºè­°
                    </button>
                    <button onclick="clearFeedbackForm()" class="danger">
                        ğŸ”„ æ¸…ç©ºè¡¨å–®
                    </button>
                </div>

                <div class="info-box" style="margin-top: 20px;">
                    <p style="color: #00ff99; font-size: 0.9em;">
                        â„¹ï¸ æ‚¨çš„å»ºè­°å°‡æœƒè¢«ç™¼é€åˆ°é–‹ç™¼åœ˜éšŠï¼Œæˆ‘å€‘æœƒä»”ç´°é–±è®€æ¯ä¸€æ¢å»ºè­°ä¸¦æŒçºŒæ”¹é€²ç³»çµ±ã€‚æ„Ÿè¬æ‚¨çš„æ”¯æŒï¼
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Discord Webhook URL
        const DISCORD_WEBHOOK = 'https://discord.com/api/webhooks/1438472081003118653/4KS7P2dGU_7KF-6tIQRgUuaLQYGPf8AZD0oDhYnUNGAJFFZKY6FhAs96O1UnLYnV9TvC';
        const FEEDBACK_WEBHOOK = 'https://discord.com/api/webhooks/1438760814466039910/iYegYu_LoPALQokZnyEjFJKuVXU9MxBHhMKvcQpZx0Ny3sKeVvUjmob0ozV5-BBHsxsj';

        // BOSS æ•¸æ“š
        const BOSS_DATA = {
            "ç´…å¯¶ç‹": { min: 23, max: 30, maps: ["æµ·å²¸è‰å¢3"], color: "#ff4444" },
            "æ¨¹å¦–ç‹": { min: 23, max: 30, maps: ["æ±æ–¹å²©çŸ³å±±5"], color: "#8bc34a" },
            "å†¥ç•Œå¹½éˆ": { min: 45, max: 60, maps: ["1è™Ÿç·š<4å€>", "2è™Ÿç·š<3å€>"], color: "#9c27b0" },
            "å·¨å±…èŸ¹": { min: 45, max: 60, maps: ["æµ·é¾œæ²™ç˜"], color: "#ff9800" },
            "æ®­å±çŒ´ç‹": { min: 38, max: 45, maps: ["å·«å©†æ£®æ—1"], color: "#795548" },
            "è˜‘è‡ç‹": { min: 195, max: 225, maps: ["é‹¼ä¹‹è‚¥è‚¥å…¬åœ’3"], color: "#ff5722" },
            "æ²¼æ¾¤å·¨é±·": { min: 90, max: 105, maps: ["å±éšªçš„é»‘é±·é­š1"], color: "#4caf50" },
            "æ®­å±è˜‘è‡ç‹": { min: 195, max: 225, maps: ["è˜‘è‡ç‹ä¹‹å¢“"], color: "#e91e63" },
            "å·´æ´›å¤": { min: 195, max: 225, maps: ["å—è©›å’’çš„ç¥æ®¿"], color: "#ff0000" },
            "è‰¾åˆ©å‚‘": { min: 118, max: 128, maps: ["å¤©ç©ºéšæ¢¯2"], color: "#00bcd4" },
            "é›ªå±±å¥³å·«": { min: 158, max: 180, maps: ["å†°é¢1"], color: "#87ceeb" },
            "é›ªæ¯›æ€ªäºº": { min: 45, max: 68, maps: ["é›ªäººä¹‹è°·"], color: "#f0f8ff" },
            "å„é‹æ­»ç¥": { min: 45, max: 105, maps: ["æ­»äº¡æ£®æ—4"], color: "#2f4f4f" },
            "å’•å’•é˜": { min: 68, max: 90, maps: ["æ™‚é–“ä¹‹è·¯<3>"], color: "#daa520" },
            "è‘›é›·é‡‘å‰›": { min: 270, max: 350, maps: ["è‘›é›·è‰åŸ"], color: "#8b4513" },
            "æ›¸ç”Ÿå¹½éˆ": { min: 150, max: 300, maps: ["ç‹ç‹¸è°·"], color: "#9370db" },
            "ä¹å°¾å¦–ç‹": { min: 210, max: 570, maps: ["æœˆäº®å±±å¡"], color: "#ff69b4" },
            "é»‘è¼ªç‹": { min: 780, max: 1020, maps: ["å¤œå¸‚å¾’æ­¥å€7"], color: "#000000" },
            "ç˜‹ç‹‚å–µzå®¢": { min: 110, max: 420, maps: ["åäººå¤§é“è¥¿éƒ¨å€åŸŸ"], color: "#ffa500" },
            "ä»™äººå¨ƒå¨ƒ": { min: 158, max: 180, maps: ["ä¸Šç´šè¨“ç·´å ´"], color: "#98fb98" },
            "è‚¯å¾·ç†Š": { min: 113, max: 128, maps: ["æµæµªç†Šçš„é ˜åœŸ"], color: "#8b7355" },
            "å–µæ€ªä»™äºº": { min: 150, max: 170, maps: ["å–µæ€ªä»™äººçš„é ˜åŸŸ"], color: "#ffb6c1" },
            "å·¨å¤§æ·±å±±äººè”˜": { min: 60, max: 135, maps: ["è±é¥’çš„è—¥è‰ç”°"], color: "#ffd700" },
            "æµ·æ€’æ–¯": { min: 180, max: 300, maps: ["æµ·æ€’æ–¯æ´ç©´"], color: "#1e90ff" }
        };

        // å­˜å„²æ•¸æ“š
        let activeBosses = [];
        let patrolRecords = [];

        // åˆå§‹åŒ–
        function init() {
            loadData();
            populateBossSelect();
            populateBossListTable();
            updateAllDisplays();
            setInterval(checkNotifications, 60000); // æ¯åˆ†é˜æª¢æŸ¥ä¸€æ¬¡
            setInterval(updateAllDisplays, 10000); // æ¯10ç§’æ›´æ–°ä¸€æ¬¡

            // æ·»åŠ Enteréµç›£è½
            document.getElementById('channel-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    recordBoss();
                }
            });
        }

        // å¡«å……BOSSé¸æ“‡åˆ—è¡¨
        function populateBossSelect() {
            const select = document.getElementById('boss-select');
            Object.keys(BOSS_DATA).forEach(boss => {
                const option = document.createElement('option');
                option.value = boss;
                option.textContent = boss;
                select.appendChild(option);
            });
        }

        // å¡«å……BOSSåˆ—è¡¨è¡¨æ ¼
        function populateBossListTable() {
            const tbody = document.getElementById('boss-list-tbody');
            tbody.innerHTML = '';
            Object.entries(BOSS_DATA).forEach(([name, info]) => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = name;
                row.insertCell(1).textContent = formatTimeRange(info.min, info.max);
                row.insertCell(2).textContent = info.maps.join(', ');
            });
        }

        // æ ¼å¼åŒ–æ™‚é–“ç¯„åœ
        function formatTimeRange(min, max) {
            if (min >= 60) {
                return `${Math.floor(min/60)}å°æ™‚${min%60}åˆ† ~ ${Math.floor(max/60)}å°æ™‚${max%60}åˆ†`;
            }
            return `${min} ~ ${max}åˆ†é˜`;
        }

        // BOSSé¸æ“‡äº‹ä»¶
        function onBossSelected() {
            const bossName = document.getElementById('boss-select').value;
            if (bossName && BOSS_DATA[bossName]) {
                const info = BOSS_DATA[bossName];
                document.getElementById('map-info').textContent = `åœ°åœ–: ${info.maps.join(', ')}`;
                document.getElementById('time-info').textContent = `é‡ç”Ÿæ™‚é–“: ${formatTimeRange(info.min, info.max)}`;
                document.getElementById('boss-info').style.display = 'block';
            } else {
                document.getElementById('boss-info').style.display = 'none';
            }
        }

        // è¨˜éŒ„BOSSæ“Šæ®º
        function recordBoss() {
            const bossName = document.getElementById('boss-select').value;
            const channel = document.getElementById('channel-input').value;
            const notification = true; // é»˜èªé–‹å•Ÿæé†’

            if (!bossName) {
                showNotification('è«‹é¸æ“‡BOSS', 'warning');
                return;
            }

            if (!channel) {
                showNotification('è«‹è¼¸å…¥é »é“', 'warning');
                return;
            }

            const info = BOSS_DATA[bossName];
            const now = new Date();
            const respawnMin = new Date(now.getTime() + info.min * 60000);
            const respawnMax = new Date(now.getTime() + info.max * 60000);

            const record = {
                id: Date.now(),
                channel: channel,
                bossName: bossName,
                deathTime: now.toISOString(),
                respawnMin: respawnMin.toISOString(),
                respawnMax: respawnMax.toISOString(),
                notified: false,
                notificationEnabled: notification,
                lastPatrolTime: null
            };

            activeBosses.push(record);
            saveData();
            updateAllDisplays();

            showNotification(
                `é »é“ ${channel} - ${bossName} æ“Šæ®ºæ™‚é–“å·²è¨˜éŒ„ï¼\né è¨ˆé‡ç”Ÿ: ${formatTime(respawnMin)} ~ ${formatTime(respawnMax)}`,
                'success'
            );

            // æ¸…ç©ºè¼¸å…¥
            document.getElementById('channel-input').value = '';
            document.getElementById('channel-input').focus();
        }

        // åˆªé™¤å–®å€‹è¨˜éŒ„
        function deleteRecord(id) {
            if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤è¨˜éŒ„å—ï¼Ÿ')) {
                activeBosses = activeBosses.filter(b => b.id !== id);
                saveData();
                updateAllDisplays();
                showNotification('å·²åˆªé™¤BOSSè¨˜éŒ„', 'success');
            }
        }

        // é‡æ–°è¨ˆæ™‚å–®å€‹BOSS
        function respawnSingleBoss(id) {
            const record = activeBosses.find(b => b.id === id);
            if (record) {
                const info = BOSS_DATA[record.bossName];
                const now = new Date();
                record.deathTime = now.toISOString();
                record.respawnMin = new Date(now.getTime() + info.min * 60000).toISOString();
                record.respawnMax = new Date(now.getTime() + info.max * 60000).toISOString();
                record.notified = false;
                
                saveData();
                updateAllDisplays();
                showNotification(`å·²é‡æ–°è¨ˆæ™‚ ${record.bossName}ï¼`, 'success');
            }
        }

        // å·¡é‚æ‰“å¡å–®å€‹BOSS
        function patrolSingleBoss(id) {
            const record = activeBosses.find(b => b.id === id);
            if (record) {
                const now = new Date();
                record.lastPatrolTime = now.toISOString();
                
                patrolRecords.push({
                    timestamp: now.toISOString(),
                    bossName: record.bossName,
                    channel: record.channel,
                    result: 'æœªé‡ç”Ÿ',
                    note: 'å¾BOSSè¨˜éŒ„å·¡é‚æ‰“å¡'
                });

                saveData();
                updateAllDisplays();
                showNotification(
                    `å·¡é‚æ‰“å¡è¨˜éŒ„å·²å„²å­˜ï¼\nBOSS: ${record.bossName}\né »é“: ${record.channel}`,
                    'success'
                );
            }
        }

        // åˆªé™¤è¨˜éŒ„
        function deleteRecords() {
            const selected = getSelectedRecords();
            if (selected.length === 0) {
                showNotification('è«‹é¸æ“‡è¦åˆªé™¤çš„è¨˜éŒ„', 'warning');
                return;
            }

            if (confirm(`ç¢ºå®šè¦åˆªé™¤ ${selected.length} å€‹è¨˜éŒ„å—ï¼Ÿ`)) {
                activeBosses = activeBosses.filter(b => !selected.includes(b.id));
                saveData();
                updateAllDisplays();
                showNotification(`å·²åˆªé™¤ ${selected.length} å€‹BOSSè¨˜éŒ„`, 'success');
            }
        }

        // é‡æ–°è¨ˆæ™‚BOSS
        function respawnBoss() {
            const selected = getSelectedRecords();
            if (selected.length === 0) {
                showNotification('è«‹é¸æ“‡è¦é‡æ–°è¨ˆæ™‚çš„BOSSè¨˜éŒ„', 'warning');
                return;
            }

            selected.forEach(id => {
                const record = activeBosses.find(b => b.id === id);
                if (record) {
                    const info = BOSS_DATA[record.bossName];
                    const now = new Date();
                    record.deathTime = now.toISOString();
                    record.respawnMin = new Date(now.getTime() + info.min * 60000).toISOString();
                    record.respawnMax = new Date(now.getTime() + info.max * 60000).toISOString();
                    record.notified = false;
                }
            });

            saveData();
            updateAllDisplays();
            showNotification(`å·²é‡æ–°è¨ˆæ™‚ ${selected.length} å€‹BOSSï¼`, 'success');
        }

        // å·¡é‚æ‰“å¡
        function patrolBoss() {
            const selected = getSelectedRecords();
            if (selected.length === 0) {
                showNotification('è«‹é¸æ“‡è¦å·¡é‚æ‰“å¡çš„BOSSè¨˜éŒ„', 'warning');
                return;
            }

            const id = selected[0];
            const record = activeBosses.find(b => b.id === id);
            if (record) {
                const now = new Date();
                record.lastPatrolTime = now.toISOString();
                
                patrolRecords.push({
                    timestamp: now.toISOString(),
                    bossName: record.bossName,
                    channel: record.channel,
                    result: 'æœªé‡ç”Ÿ',
                    note: 'å¾BOSSè¨˜éŒ„å·¡é‚æ‰“å¡'
                });

                saveData();
                updateAllDisplays();
                showNotification(
                    `å·¡é‚æ‰“å¡è¨˜éŒ„å·²å„²å­˜ï¼\nBOSS: ${record.bossName}\né »é“: ${record.channel}\næ™‚é–“: ${formatTime(now)}`,
                    'success'
                );
            }
        }

        // æ¸…ç©ºæ‰€æœ‰è¨˜éŒ„
        function clearAll() {
            if (activeBosses.length === 0) {
                showNotification('ç›®å‰æ²’æœ‰è¨˜éŒ„', 'warning');
                return;
            }

            if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰BOSSè¨˜éŒ„å—ï¼Ÿ')) {
                activeBosses = [];
                saveData();
                updateAllDisplays();
                showNotification('å·²æ¸…ç©ºæ‰€æœ‰è¨˜éŒ„', 'success');
            }
        }

        // ç²å–é¸ä¸­çš„è¨˜éŒ„ID
        function getSelectedRecords() {
            const checkboxes = document.querySelectorAll('#record-tbody input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => parseInt(cb.dataset.id));
        }

        // åˆ‡æ›å…¨é¸
        function toggleSelectAll() {
            const selectAll = document.getElementById('select-all').checked;
            document.querySelectorAll('#record-tbody input[type="checkbox"]').forEach(cb => {
                cb.checked = selectAll;
            });
        }

        // æ›´æ–°æ‰€æœ‰é¡¯ç¤º
        function updateAllDisplays() {
            updateRecordDisplay();
            updateStatusDisplay();
        }

        // æ›´æ–°è¨˜éŒ„é¡¯ç¤º
        function updateRecordDisplay() {
            const tbody = document.getElementById('record-tbody');
            tbody.innerHTML = '';

            const sorted = [...activeBosses].sort((a, b) => 
                new Date(a.respawnMin) - new Date(b.respawnMin)
            );

            sorted.forEach(record => {
                const row = tbody.insertRow();
                
                // è¤‡é¸æ¡†
                const checkCell = row.insertCell(0);
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.dataset.id = record.id;
                checkCell.appendChild(checkbox);

                row.insertCell(1).textContent = record.bossName;
                row.insertCell(2).textContent = record.channel;
                row.insertCell(3).textContent = formatDateTime(new Date(record.deathTime));
                row.insertCell(4).textContent = formatDateTime(new Date(record.respawnMin));
                row.insertCell(5).textContent = formatDateTime(new Date(record.respawnMax));

                const statusCell = row.insertCell(6);
                const status = getStatus(record);
                statusCell.textContent = status.text;
                statusCell.className = status.className;

                row.insertCell(7).textContent = record.lastPatrolTime ? formatTime(new Date(record.lastPatrolTime)) : '';
                
                // æ“ä½œæŒ‰éˆ•
                const actionCell = row.insertCell(8);
                actionCell.innerHTML = `
                    <button onclick="deleteRecord(${record.id})" style="padding: 5px 10px; margin: 2px; font-size: 0.9em;">ğŸ—‘ï¸</button>
                    <button onclick="respawnSingleBoss(${record.id})" style="padding: 5px 10px; margin: 2px; font-size: 0.9em;">ğŸ”„</button>
                    <button onclick="patrolSingleBoss(${record.id})" style="padding: 5px 10px; margin: 2px; font-size: 0.9em;">ğŸ‘€</button>
                `;
            });
        }

        // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
        function updateStatusDisplay() {
            const display = document.getElementById('status-display');
            const now = new Date();
            
            document.getElementById('current-time').textContent = 
                `ç•¶å‰æ™‚é–“: ${formatDateTime(now, true)}`;

            if (activeBosses.length === 0) {
                display.innerHTML = '<p style="text-align: center; color: #a0a0c0;">ç›®å‰æ²’æœ‰è¨˜éŒ„ä¸­çš„BOSS</p>';
                return;
            }

            const sorted = [...activeBosses].sort((a, b) => 
                new Date(a.respawnMin) - new Date(b.respawnMin)
            );

            let html = '';
            sorted.forEach(record => {
                const status = getStatus(record);
                const respawnMin = new Date(record.respawnMin);
                const respawnMax = new Date(record.respawnMax);
                
                let timeInfo;
                if (now < respawnMin) {
                    const diff = Math.floor((respawnMin - now) / 60000);
                    timeInfo = `å‰©é¤˜: ${diff}åˆ†é˜`;
                } else if (now >= respawnMin && now <= respawnMax) {
                    const diff = Math.floor((respawnMax - now) / 60000);
                    timeInfo = `å·²é€²å…¥é‡ç”Ÿçª—å£ï¼Œ${diff}åˆ†é˜å¾ŒçµæŸ`;
                } else {
                    const diff = Math.floor((now - respawnMax) / 60000);
                    timeInfo = `å·²è¶…é: ${diff}åˆ†é˜`;
                }

                let patrolInfo = '';
                if (record.lastPatrolTime) {
                    const diff = Math.floor((now - new Date(record.lastPatrolTime)) / 60000);
                    patrolInfo = ` | æœ€å¾Œå·¡é‚: ${diff}åˆ†é˜å‰`;
                }

                html += `
                    <div class="boss-status-card">
                        <h3>ã€${record.bossName}ã€‘é »é“ ${record.channel}</h3>
                        <p class="${status.className}">ç‹€æ…‹: ${status.text}</p>
                        <p>æ“Šæ®ºæ™‚é–“: ${formatDateTime(new Date(record.deathTime))}</p>
                        <p>é‡ç”Ÿæ™‚é–“: ${formatTime(respawnMin)} ~ ${formatTime(respawnMax)}</p>
                        <p>${timeInfo}${patrolInfo}</p>
                    </div>
                `;
            });

            display.innerHTML = html;
        }

        // ç²å–BOSSç‹€æ…‹
        function getStatus(record) {
            const now = new Date();
            const respawnMin = new Date(record.respawnMin);
            const respawnMax = new Date(record.respawnMax);

            if (now < respawnMin) {
                const diff = Math.floor((respawnMin - now) / 60000);
                return { text: `ç­‰å¾…ä¸­ (${diff}åˆ†)`, className: 'status-waiting' };
            } else if (now >= respawnMin && now <= respawnMax) {
                return { text: 'ğŸ”´ å¯èƒ½å·²é‡ç”Ÿï¼', className: 'status-possible' };
            } else {
                return { text: 'â° è‚¯å®šå·²é‡ç”Ÿï¼', className: 'status-definite' };
            }
        }

        // æª¢æŸ¥é€šçŸ¥
        async function checkNotifications() {
            const now = new Date();
            const toNotify = [];
            
            // é™å®šBOSS
            const notifyBosses = ['è˜‘è‡ç‹', 'æ®­å±è˜‘è‡ç‹', 'å·´æ´›å¤', 'é»‘è¼ªç‹', 'ç˜‹ç‹‚å–µzå®¢'];

            activeBosses.forEach(record => {
                if (record.notificationEnabled && !record.notified && 
                    new Date(record.respawnMin) <= now &&
                    notifyBosses.includes(record.bossName)) {
                    record.notified = true;
                    toNotify.push(record);
                }
            });

            if (toNotify.length > 0) {
                saveData();
                for (const record of toNotify) {
                    await sendDiscordNotification(record);
                }
            }
        }

        // ç™¼é€é€šçŸ¥
        async function sendDiscordNotification(record) {
            const respawnMin = new Date(record.respawnMin);
            const respawnMax = new Date(record.respawnMax);

            const embed = {
                title: 'ğŸ”” BOSSé‡ç”Ÿæé†’',
                description: `**${record.bossName}** å¯èƒ½å·²ç¶“é‡ç”Ÿï¼`,
                color: parseInt(BOSS_DATA[record.bossName]?.color?.replace('#', '') || 'FF0000', 16),
                fields: [
                    {
                        name: 'é »é“',
                        value: record.channel,
                        inline: true
                    },
                    {
                        name: 'åœ°åœ–',
                        value: BOSS_DATA[record.bossName]?.maps.join(', ') || 'æœªçŸ¥',
                        inline: true
                    },
                    {
                        name: 'é‡ç”Ÿæ™‚é–“ç¯„åœ',
                        value: `${formatTime(respawnMin)} ~ ${formatTime(respawnMax)}`,
                        inline: false
                    }
                ],
                timestamp: new Date().toISOString(),
                footer: {
                    text: 'æ¥“ä¹‹è°·BOSSé‡ç”Ÿæ™‚é–“ç³»çµ±'
                }
            };

            try {
                await fetch(DISCORD_WEBHOOK, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        embeds: [embed]
                    })
                });
                // ä¸é¡¯ç¤ºä»»ä½•éŒ¯èª¤æˆ–æˆåŠŸè¨Šæ¯
            } catch (error) {
                // éœé»˜è™•ç†éŒ¯èª¤ï¼Œä¸åœ¨UIé¡¯ç¤º
            }
        }

        // é¡¯ç¤ºé€šçŸ¥
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `<p style="white-space: pre-line;">${message}</p>`;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 5000);
        }

        // åˆ‡æ›æ¨™ç±¤
        function switchTab(index) {
            const tabs = document.querySelectorAll('.tab');
            const contents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => tab.classList.remove('active'));
            contents.forEach(content => content.classList.remove('active'));

            tabs[index].classList.add('active');
            contents[index].classList.add('active');
        }

        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(date) {
            return date.toLocaleTimeString('zh-TW', { hour: '2-digit', minute: '2-digit' });
        }

        function formatDateTime(date, withSeconds = false) {
            const options = { 
                month: '2-digit', 
                day: '2-digit', 
                hour: '2-digit', 
                minute: '2-digit'
            };
            if (withSeconds) {
                options.second = '2-digit';
            }
            return date.toLocaleString('zh-TW', options).replace(/\//g, '/');
        }

        // æäº¤æ”¹å–„å»ºè­°
        async function submitFeedback() {
            const type = document.getElementById('feedback-type').value;
            const content = document.getElementById('feedback-content').value.trim();
            const contact = document.getElementById('feedback-contact').value.trim();

            if (!content) {
                showNotification('è«‹è¼¸å…¥è©³ç´°èªªæ˜', 'warning');
                return;
            }

            const now = new Date();
            const embed = {
                title: 'ğŸ“ æ–°çš„æ”¹å–„å»ºè­°',
                color: 0x00ccff,
                fields: [
                    {
                        name: 'ğŸ“‹ å»ºè­°é¡å‹',
                        value: type,
                        inline: true
                    },
                    {
                        name: 'ğŸ•’ æäº¤æ™‚é–“',
                        value: formatDateTime(now, true),
                        inline: true
                    },
                    {
                        name: 'ğŸ’¬ è©³ç´°èªªæ˜',
                        value: content.length > 1024 ? content.substring(0, 1021) + '...' : content,
                        inline: false
                    }
                ],
                timestamp: now.toISOString(),
                footer: {
                    text: 'æ¥“ä¹‹è°·BOSSé‡ç”Ÿæ™‚é–“ç³»çµ± - æ”¹å–„å»ºè­°'
                }
            };

            if (contact) {
                embed.fields.push({
                    name: 'ğŸ“§ è¯çµ¡æ–¹å¼',
                    value: contact,
                    inline: false
                });
            }

            try {
                const response = await fetch(FEEDBACK_WEBHOOK, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        embeds: [embed]
                    })
                });

                if (response.ok) {
                    showNotification('æ„Ÿè¬æ‚¨çš„å»ºè­°ï¼å·²æˆåŠŸæäº¤ âœ¨', 'success');
                    clearFeedbackForm();
                } else {
                    showNotification('æäº¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦', 'error');
                }
            } catch (error) {
                showNotification('æäº¤å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·š', 'error');
            }
        }

        // æ¸…ç©ºæ”¹å–„å»ºè­°è¡¨å–®
        function clearFeedbackForm() {
            document.getElementById('feedback-type').value = 'åŠŸèƒ½å»ºè­°';
            document.getElementById('feedback-content').value = '';
            document.getElementById('feedback-contact').value = '';
        }

        // ä¿å­˜æ•¸æ“šåˆ°localStorage
        function saveData() {
            localStorage.setItem('activeBosses', JSON.stringify(activeBosses));
            localStorage.setItem('patrolRecords', JSON.stringify(patrolRecords));
        }

        // è¼‰å…¥æ•¸æ“š
        function loadData() {
            const savedBosses = localStorage.getItem('activeBosses');
            const savedPatrols = localStorage.getItem('patrolRecords');

            if (savedBosses) {
                try {
                    activeBosses = JSON.parse(savedBosses);
                } catch (e) {
                    console.error('è¼‰å…¥BOSSæ•¸æ“šå¤±æ•—:', e);
                }
            }

            if (savedPatrols) {
                try {
                    patrolRecords = JSON.parse(savedPatrols);
                } catch (e) {
                    console.error('è¼‰å…¥å·¡é‚è¨˜éŒ„å¤±æ•—:', e);
                }
            }
        }

        // é é¢è¼‰å…¥æ™‚åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
